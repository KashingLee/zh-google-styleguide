3. 类
------------

类是 C++ 中代码的基本单元. 显然, 它们被广泛使用. 本节列举了在写一个类时的主要注意事项.

.. _inheritance:

3.1. 继承
~~~~~~~~~~~~~~~~~~~~~

.. tip::
    使用组合 (composition, YuleFox 注: 这一点也是 GoF 在 <<Design Patterns>> 里反复强调的) 常常比使用继承更合理. 如果使用继承的话, 定义为 ``public`` 继承.

定义:
    当子类继承基类时, 子类包含了父基类所有数据及操作的定义. C++ 实践中, 继承主要用于两种场合: 实现继承 (implementation inheritance), 子类继承父类的实现代码; 接口继承 (interface inheritance), 子类仅继承父类的方法名称.

优点:
    实现继承通过原封不动的复用基类代码减少了代码量. 由于继承是在编译时声明, 程序员和编译器都可以理解相应操作并发现错误. 从编程角度而言, 接口继承是用来强制类输出特定的 API. 在类没有实现 API 中某个必须的方法时, 编译器同样会发现并报告错误.

缺点:
    对于实现继承, 由于子类的实现代码散布在父类和子类间之间, 要理解其实现变得更加困难. 子类不能重写父类的非虚函数, 当然也就不能修改其实现. 基类也可能定义了一些数据成员, 还要区分基类的实际布局.

结论:
    所有继承必须是 ``public`` 的. 如果你想使用私有继承, 你应该替换成把基类的实例作为成员对象的方式.
    
    不要过度使用实现继承. 组合常常更合适一些. 尽量做到只在 "是一个" ("is-a", YuleFox 注: 其他 "has-a" 情况下请使用组合) 的情况下使用继承: 如果 ``Bar`` 的确 "是一种" Foo, ``Bar`` 才能继承 ``Foo``.
    
    必要的话, 析构函数声明为 ``virtual``. 如果你的类有虚函数, 则析构函数也应该为虚函数. 注意 `数据成员在任何情况下都必须是私有的 <....>`_.
    
    当重载一个虚函数, 在衍生类中把它明确的声明为 ``virtual``. 理论依据: 如果省略 ``virtual`` 关键字, 代码阅读者不得不检查所有父类, 以判断该函数是否是虚函数.
    
3.2. 存取控制
~~~~~~~~~~~~~~~~~~~~~

.. tip::
    将 *所有* 数据成员声明为 ``private``, 并根据需要提供相应的存取函数. 例如, 某个名为 ``foo_`` 的变量, 其取值函数是 ``foo()``. 还可能需要一个赋值函数 ``set_foo()``.

一般在头文件中把存取函数定义成内联函数.

参考 :ref:`继承 <inheritance>` 和 :ref:`函数命名 <function-names>`

.. _declaration-order:

3.3. 声明顺序
~~~~~~~~~~~~~~~~~~~~~

.. tip::
    在类中使用特定的声明顺序: ``public:`` 在 ``private:`` 之前, 成员函数在数据成员 (变量) 前;
    
类的访问控制区段的声明顺序依次为: ``public:``, ``protected:``, ``private:``. 如果某区段没内容, 可以不声明.

每个区段内的声明通常按以下顺序:
    
    - ``typedefs`` 和枚举
    - 常量
    - 构造函数
    - 析构函数
    - 成员函数, 含静态成员函数
    - 数据成员, 含静态数据成员

宏 ``DISALLOW_COPY_AND_ASSIGN`` 的调用放在 ``private:`` 区段的末尾. 它通常是类的最后部分. 参考 :ref:`拷贝构造函数 <copy-constructors>`.

``.cc`` 文件中函数的定义应尽可能和声明顺序一致.

不要在类定义中内联大型函数. 通常, 只有那些没有特别意义或性能要求高, 并且是比较短小的函数才能被定义为内联函数. 更多细节参考 :ref:`内联函数 <inline-functions>`.

3.4. 编写简短函数
~~~~~~~~~~~~~~~~~~~~~

.. tip::
    倾向编写简短, 凝练的函数.
    
我们承认长函数有时是合理的, 因此并不硬性限制函数的长度. 如果函数超过 40 行, 可以思索一下能不能在不影响程序结构的前提下对其进行分割.

即使一个长函数现在工作的非常好, 一旦有人对其修改, 有可能出现新的问题. 甚至导致难以发现的 bug. 使函数尽量简短, 便于他人阅读和修改代码.

在处理代码时, 你可能会发现复杂的长函数. 不要害怕修改现有代码: 如果证实这些代码使用 / 调试困难, 或者你需要使用其中的一小段代码, 考虑将其分割为更加简短并易于管理的若干函数.

